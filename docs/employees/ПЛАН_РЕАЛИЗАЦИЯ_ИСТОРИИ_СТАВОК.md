# План реализации: хранение и учёт историй ставок сотрудников

## 1. Цели изменений
- Ввести историю почасовых ставок с датами действия для каждого сотрудника.
- Обеспечить расчёты ФОТ использованием ставки, актуальной на дату работы.
- Сохранить существующий UX: редактирование ставки в форме сотрудника должно оставаться простым.
- Создать отдельную таблицу `employee_rates` с простой и понятной логикой.

## 2. Новая структура базы данных

### 2.1. Таблица `employee_rates`
```sql
CREATE TABLE employee_rates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  employee_id UUID NOT NULL REFERENCES employees(id) ON DELETE CASCADE,
  hourly_rate NUMERIC(10,2) NOT NULL,
  valid_from DATE NOT NULL,
  valid_to DATE NULL, -- NULL означает действующая ставка
  created_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES profiles(id),
  
  -- Ограничения
  CONSTRAINT valid_dates_check CHECK (valid_to IS NULL OR valid_to >= valid_from),
  CONSTRAINT positive_rate_check CHECK (hourly_rate > 0)
);

-- Индексы для быстрого поиска
CREATE INDEX idx_employee_rates_employee_id ON employee_rates(employee_id);
CREATE INDEX idx_employee_rates_dates ON employee_rates(employee_id, valid_from, valid_to);
CREATE INDEX idx_employee_rates_active ON employee_rates(employee_id) WHERE valid_to IS NULL;

-- Уникальное ограничение: только одна активная ставка на сотрудника
CREATE UNIQUE INDEX idx_employee_rates_active_unique 
ON employee_rates(employee_id) WHERE valid_to IS NULL;
```

### 2.2. RLS (Row Level Security)
```sql
ALTER TABLE employee_rates ENABLE ROW LEVEL SECURITY;

-- Просмотр для всех аутентифицированных пользователей
CREATE POLICY "Users can view employee rates"
  ON employee_rates FOR SELECT
  USING (auth.role() = 'authenticated');

-- Изменения только для администраторов
CREATE POLICY "Only admins can modify employee rates" 
  ON employee_rates FOR ALL
  USING (auth.role() = 'authenticated' AND 
         (SELECT role FROM profiles WHERE id = auth.uid()) = 'admin');
```

### 2.3. Функция для получения актуальной ставки
```sql
-- Функция для получения ставки на конкретную дату
CREATE OR REPLACE FUNCTION get_employee_rate(p_employee_id UUID, p_date DATE)
RETURNS NUMERIC(10,2) AS $$
DECLARE
  result NUMERIC(10,2);
BEGIN
  SELECT hourly_rate INTO result
  FROM employee_rates
  WHERE employee_id = p_employee_id
    AND valid_from <= p_date
    AND (valid_to IS NULL OR valid_to >= p_date)
  ORDER BY valid_from DESC
  LIMIT 1;
  
  RETURN COALESCE(result, 0);
END;
$$ LANGUAGE plpgsql STABLE;
```

## 3. Миграция существующих данных
```sql
-- Миграция: перенос текущих ставок из employees в employee_rates
INSERT INTO employee_rates (employee_id, hourly_rate, valid_from, created_at)
SELECT 
  id,
  hourly_rate,
  COALESCE(employment_date::DATE, created_at::DATE),
  NOW()
FROM employees 
WHERE hourly_rate IS NOT NULL AND hourly_rate > 0;

-- Сохраняем поле hourly_rate в employees для обратной совместимости
-- Но теперь оно будет синхронизироваться с employee_rates
```

## 4. Изменения в Flutter: Data слой

### 4.1. Новая модель `EmployeeRateModel`
```dart
@freezed
abstract class EmployeeRateModel with _$EmployeeRateModel {
  @JsonSerializable(fieldRename: FieldRename.snake)
  const factory EmployeeRateModel({
    required String id,
    required String employeeId,
    required double hourlyRate,
    required DateTime validFrom,
    DateTime? validTo,
    DateTime? createdAt,
    String? createdBy,
  }) = _EmployeeRateModel;

  factory EmployeeRateModel.fromJson(Map<String, dynamic> json) =>
      _$EmployeeRateModelFromJson(json);
}
```

### 4.2. Новый `EmployeeRateDataSource`
```dart
abstract class EmployeeRateDataSource {
  Future<List<EmployeeRateModel>> getEmployeeRates(String employeeId);
  Future<EmployeeRateModel?> getCurrentRate(String employeeId);
  Future<double> getRateForDate(String employeeId, DateTime date);
  Future<void> setNewRate(String employeeId, double rate, DateTime validFrom);
  Future<void> closeCurrentRate(String employeeId, DateTime validTo);
}

class EmployeeRateDataSourceImpl implements EmployeeRateDataSource {
  final SupabaseClient client;
  
  @override
  Future<double> getRateForDate(String employeeId, DateTime date) async {
    final result = await client.rpc('get_employee_rate', params: {
      'p_employee_id': employeeId,
      'p_date': date.toIso8601String().split('T')[0], // только дата
    });
    return (result as num?)?.toDouble() ?? 0.0;
  }
  
  @override
  Future<void> setNewRate(String employeeId, double rate, DateTime validFrom) async {
    await client.from('employee_rates').insert({
      'employee_id': employeeId,
      'hourly_rate': rate,
      'valid_from': validFrom.toIso8601String().split('T')[0],
    });
    
    // Синхронизируем с employees.hourly_rate
    await client.from('employees').update({
      'hourly_rate': rate,
    }).eq('id', employeeId);
  }
}
```

## 5. Изменения в Domain слое

### 5.1. Новая сущность `EmployeeRate`
```dart
@freezed
abstract class EmployeeRate with _$EmployeeRate {
  const factory EmployeeRate({
    required String id,
    required String employeeId,
    required double hourlyRate,
    required DateTime validFrom,
    DateTime? validTo,
    DateTime? createdAt,
    String? createdBy,
  }) = _EmployeeRate;
  
  const EmployeeRate._();
  
  /// Проверяет, действует ли ставка на указанную дату
  bool isActiveOn(DateTime date) {
    return validFrom.isBefore(date.add(Duration(days: 1))) &&
           (validTo == null || validTo!.isAfter(date.subtract(Duration(days: 1))));
  }
  
  /// Является ли эта ставка текущей (активной)
  bool get isCurrent => validTo == null;
}
```

### 5.2. Новые Use Cases
```dart
// Получение ставки на дату
class GetEmployeeRateForDateUseCase {
  final EmployeeRateRepository repository;
  
  Future<double> call(String employeeId, DateTime date) async {
    return await repository.getRateForDate(employeeId, date);
  }
}

// Установка новой ставки
class SetEmployeeRateUseCase {
  final EmployeeRateRepository repository;
  
  Future<void> call(String employeeId, double newRate, DateTime validFrom) async {
    // 1. Закрываем текущую ставку (если есть)
    await repository.closeCurrentRate(employeeId, validFrom.subtract(Duration(days: 1)));
    
    // 2. Создаём новую ставку
    await repository.setNewRate(employeeId, newRate, validFrom);
  }
}
```

## 6. Обновление расчётов ФОТ

### 6.1. Изменения в `payroll_providers.dart`
```dart
// Заменяем строку 241-242:
// final hourlyRate = employee?.hourlyRate ?? 0.0;

// На:
final rateDataSource = ref.read(employeeRateDataSourceProvider);
final hourlyRate = await rateDataSource.getRateForDate(employeeId, entry.date);
```

### 6.2. Кэширование ставок
```dart
// Провайдер для кэширования ставок за период
final employeeRatesForPeriodProvider = FutureProvider.family<Map<String, double>, PayrollPeriod>((ref, period) async {
  final rateDataSource = ref.read(employeeRateDataSourceProvider);
  final employees = ref.read(employeesProvider).value ?? [];
  
  final ratesMap = <String, double>{};
  
  for (final employee in employees) {
    // Берём ставку на первый день периода для простоты
    // В реальности может потребоваться более сложная логика
    final rate = await rateDataSource.getRateForDate(employee.id, period.startDate);
    ratesMap[employee.id] = rate;
  }
  
  return ratesMap;
});
```

## 7. Обновление UI (минимальные изменения)

### 7.1. Форма сотрудника остаётся прежней
- Поле "Ставка" продолжает работать как обычно
- При сохранении вызывается `SetEmployeeRateUseCase` с `validFrom = DateTime.now()`

### 7.2. Экран деталей сотрудника
```dart
// Добавляем отображение истории ставок (опционально)
class EmployeeRateHistoryWidget extends ConsumerWidget {
  final String employeeId;
  
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final ratesAsync = ref.watch(employeeRatesProvider(employeeId));
    
    return ratesAsync.when(
      data: (rates) => Column(
        children: rates.map((rate) => Card(
          child: ListTile(
            title: Text('${formatCurrency(rate.hourlyRate)}/час'),
            subtitle: Text(
              '${formatRuDate(rate.validFrom)} - ${rate.validTo != null ? formatRuDate(rate.validTo!) : 'по настоящее время'}'
            ),
            trailing: rate.isCurrent ? Chip(label: Text('Текущая')) : null,
          ),
        )).toList(),
      ),
      loading: () => CircularProgressIndicator(),
      error: (e, s) => Text('Ошибка: $e'),
    );
  }
}
```

## 8. Детальный пример работы логики

### Сценарий: Иванов И.И. - от найма до двух повышений

**Исходные данные:**
- Сотрудник: Иванов Иван Иванович (id: 'emp-123')
- Дата найма: 01.01.2024
- Начальная ставка: 500 ₽/час

### Этап 1: Создание сотрудника (01.01.2024)

**1.1. Действие пользователя:**
- Админ создаёт сотрудника с ставкой 500 ₽/час

**1.2. Что происходит в системе:**
```sql
-- 1. Создание записи в employees
INSERT INTO employees (id, first_name, last_name, hourly_rate, employment_date, ...)
VALUES ('emp-123', 'Иван', 'Иванов', 500.00, '2024-01-01', ...);

-- 2. Создание первой записи ставки в employee_rates
INSERT INTO employee_rates (id, employee_id, hourly_rate, valid_from, valid_to)
VALUES ('rate-1', 'emp-123', 500.00, '2024-01-01', NULL);
```

**1.3. Состояние данных:**
```sql
-- employees: hourly_rate = 500.00
-- employee_rates:
-- ('rate-1', 'emp-123', 500.00, '2024-01-01', NULL) ← активная ставка
```

### Этап 2: Работа в январе-феврале 2024

**2.1. Трудовая деятельность:**
- Январь: 22 часа (даты: 15.01, 20.01, 25.01)
- Февраль: 24 часа (даты: 05.02, 12.02, 20.02)

### Этап 3: Первое повышение ставки (15.02.2024)

**3.1. Действие пользователя:**
- Админ меняет ставку с 500 на 600 ₽/час с датой действия 15.02.2024

**3.2. Что происходит в системе:**
```sql
-- 1. Закрываем текущую ставку
UPDATE employee_rates 
SET valid_to = '2024-02-14' 
WHERE employee_id = 'emp-123' AND valid_to IS NULL;

-- 2. Создаём новую ставку
INSERT INTO employee_rates (id, employee_id, hourly_rate, valid_from, valid_to)
VALUES ('rate-2', 'emp-123', 600.00, '2024-02-15', NULL);

-- 3. Обновляем текущую ставку в employees
UPDATE employees SET hourly_rate = 600.00 WHERE id = 'emp-123';
```

**3.3. Состояние данных:**
```sql
-- employee_rates:
-- ('rate-1', 'emp-123', 500.00, '2024-01-01', '2024-02-14') ← закрытая
-- ('rate-2', 'emp-123', 600.00, '2024-02-15', NULL)        ← активная
```

### Этап 4: Расчёт ФОТ за февраль 2024

**4.1. Расчёт для работы 05.02.2024:**
```sql
SELECT get_employee_rate('emp-123', '2024-02-05');
-- Результат: 500.00 (действовала rate-1)
```

**4.2. Расчёт для работы 20.02.2024:**
```sql
SELECT get_employee_rate('emp-123', '2024-02-20');
-- Результат: 600.00 (действует rate-2)
```

**4.3. Итоговый расчёт за февраль:**
- 05.02: 8 часов × 500 ₽ = 4,000 ₽
- 12.02: 8 часов × 500 ₽ = 4,000 ₽  
- 20.02: 8 часов × 600 ₽ = 4,800 ₽
- **Итого: 12,800 ₽**

### Этап 5: Второе повышение (01.03.2024 до 750 ₽/час)

**5.1. Обновление:**
```sql
-- Закрываем ставку 600 ₽/час
UPDATE employee_rates SET valid_to = '2024-02-29' WHERE id = 'rate-2';

-- Создаём ставку 750 ₽/час
INSERT INTO employee_rates VALUES ('rate-3', 'emp-123', 750.00, '2024-03-01', NULL);
```

### Итоговая история ставок:
```sql
-- employee_rates для emp-123:
-- ('rate-1', 500.00, '2024-01-01', '2024-02-14') -- январь + начало февраля
-- ('rate-2', 600.00, '2024-02-15', '2024-02-29') -- конец февраля  
-- ('rate-3', 750.00, '2024-03-01', NULL)         -- март и далее
```

## 9. Преимущества нового подхода

- ✅ **Простота и понятность**: отдельная таблица с чёткими датами действия
- ✅ **Полная история**: все изменения ставок сохраняются с точными датами
- ✅ **Гибкость**: можно задать любую дату начала действия ставки
- ✅ **Производительность**: эффективные индексы и SQL-функция
- ✅ **Надёжность**: ограничения БД исключают некорректные данные
- ✅ **Простые расчёты**: одна функция `get_employee_rate(employee_id, date)`
- ✅ **Минимальные изменения UI**: форма сотрудника остаётся прежней

## 10. План внедрения

1. **Создание миграции** - таблица, индексы, функции, RLS
2. **Перенос данных** - миграция существующих ставок
3. **Реализация data/domain слоёв** - модели, репозитории, use cases
4. **Обновление расчётов ФОT** - замена логики получения ставок
5. **Тестирование** - unit, integration, regression тесты
6. **Деплой и мониторинг** - поэтапное внедрение


