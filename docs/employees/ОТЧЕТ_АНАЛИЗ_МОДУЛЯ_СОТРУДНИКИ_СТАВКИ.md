# Отчёт: анализ модуля «Сотрудники» и назначение ставок

## 1. Цель и охват
- Выявить устройство модуля `employees` в Flutter-приложении.
- Определить, какие таблицы Supabase обслуживают функциональность сотрудников.
- Изучить, где хранятся и как назначаются почасовые ставки.
- Зафиксировать текущие точки использования ставок и статус данных.

## 2. Архитектура клиентского модуля
- **Презентационный слой**: экраны и виджеты в `lib/features/employees/presentation`, включая список сотрудников, форму (`employee_form_screen.dart`) и детали (`employee_details_screen.dart`).
- **Состояние и бизнес-логика**: доменная сущность `Employee`, use case’ы и `EmployeeNotifier` в `lib/presentation/state/employee_state.dart`, управляющие загрузкой/сохранением сотрудников через Riverpod.
- **Доступ к данным**: `SupabaseEmployeeDataSource` (`lib/data/datasources/employee_data_source.dart`) выполняет CRUD-операции с таблицей `employees`; репозиторий `EmployeeRepositoryImpl` преобразует модели между слоями.
- **DI**: зависимости подключаются через `core/di/providers.dart`, позволяя переиспользовать клиенты Supabase и use case’ы в других модулях (например, ФОТ).

## 3. Таблицы Supabase, связанные с модулем сотрудников
- `public.employees` — основная таблица. Хранит персональные данные, статусы, массив привязанных объектов, флаг `can_be_responsible` и **единственное поле для ставки** `hourly_rate (NUMERIC)`.
- `public.payroll_calculation` — рассчитанные начисления; содержит копию ставки (`hourly_rate`), но на данный момент пустая.
- `public.payroll_bonus`, `public.payroll_penalty`, `public.payroll_deduction`, `public.payroll_payout` — финансовые операции с привязкой к `employee_id` и, опосредованно, к ставке.
- `public.work_hours` — фактические часы сотрудников; при аналитике ФОТ соединяется с `employees.hourly_rate`.
- Связанные сущности: `profiles.employee_id`, `work_plan_blocks.responsible_id`, `work_plans`, `works` — используют сотрудников, но ставок не хранят.

**Размер и заполненность**: `employees` ~152 KB, 30 записей; только 3 сотрудника имеют заполненный `hourly_rate`, среднее значение ~733.33 ₽/час. Большинство ставок отсутствует, что влечёт нулевые начисления в расчётах.

## 4. Назначение и хранение ставок
- **Хранилище**: поле `hourly_rate` в таблице `employees`. Дополнительных сущностей (истории ставок, тарифных планов) нет.
- **Назначение в клиенте**: форма `employee_form_screen.dart` содержит контроллер `_hourlyRateController`; при сохранении значение парсится в `double` и сохраняется в доменную модель, затем через `updateEmployeeUseCase` попадает в Supabase.
- **Политики безопасности**: миграция `lib/data/migrations/employees_migration.sql` включает RLS; изменять записи могут только пользователи, у которых в `profiles` роль `admin`. Таким образом, назначение ставок доступно лишь администраторам.
- **Валидация**: явной проверки диапазона/формата ставки нет; ошибки парсинга приводят к сохранению `null`.
- **Отсутствующие механики**: нет автоматических расчётов/копирования ставки в связанные таблицы при редактировании, нет аудита изменений.

## 5. Использование ставок в кодовой базе
- **Детали сотрудника**: `employee_details_screen.dart` отображает ставку с единицами «₽/час». Значение выводится напрямую из `Employee.hourlyRate`.
- **Расчёт ФОТ** (`lib/features/fot/presentation/providers/payroll_providers.dart`):
  - При агрегации часов из `work_hours` ставка подтягивается из кэша сотрудников (`employee.hourlyRate`).
  - `baseSalary` считается как `hours * hourlyRate`; при `null` ставки база равна нулю.
- **Агрегированный баланс** (`balance_providers.dart`): fallback-расчёт «net salary» умножает часы из `work_hours` на `employees.hourly_rate`; отсутствие ставки приводит к нулевому базовому начислению.
- **Финансовая аналитика** (`docs/FINANCIAL_INFO.md`): рекомендует объединять `work_hours` с `employees(hourly_rate)` при расчётах — подтверждает, что ставка лежит только в `employees`.

## 6. Наблюдения по данным
- Несмотря на наличие механизма ввода, ставки заполнены лишь у 10% сотрудников. Это снижает точность модулей ФОТ и отчётности.
- Таблица `payroll_calculation` пока не используется, поэтому исторические ставки не фиксируются — любые пересчёты зависят от «текущей» ставки в `employees`.
- В `work_hours` отсутствует снимок ставки на момент смены; изменение ставки ретроспективно повлияет на все будущие расчёты.

## 7. Риски и рекомендации
- **Риск потери истории**: при изменении ставки прошлые начисления не воспроизводимы. Рекомендуется хранить историю тарифов (либо в `payroll_calculation`, либо в отдельной таблице) и писать ставку в `work_hours` или `payroll_calculation` при фиксации периода.
- **Пробелы в данных**: стоит добавить контроль заполнения ставки в форме (валидация/обязательность для рабочих ролей) либо отдельный процесс назначения тарифов.
- **Доступ**: удостовериться, что RLS политики покрывают все операции (INSERT/UPDATE/DELETE) и что `profiles` надёжно отражает роль администратора.

## 8. Использованные источники
- Код клиента: `lib/features/employees/presentation`, `lib/data/datasources/employee_data_source.dart`, `lib/presentation/state/employee_state.dart`, `lib/features/fot/presentation/providers` и `balance_providers.dart`.
- Миграции и документация: `lib/data/migrations/employees_migration.sql`, `docs/employees_module.md`, `docs/database_structure.md`, `docs/FINANCIAL_INFO.md`.
- Supabase: просмотр структуры (`list_tables`), запросы на `information_schema` и агрегаты по `employees`, `work_hours`.


